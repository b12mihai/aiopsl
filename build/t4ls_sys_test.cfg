###############################################################################
# Configuration: GPP+MC+AIOP
# 0. Load an elf file (T4LS_system_test.elf) on GPP Core-0 - this is done by using runsim elf loader
#    <path_to_sim_binaries>/runsim -t -d lsdpaa2iss -nc 0 -pnc 100000000000000000000000100000000 -smodel "ls_sim_config_file=T4LS_system_test_runsim.cfg" -tgt_init T4LSSimulator_init.mem T4LS_system_test.elf
# This example does following -
# 1. Loads a elf file on MC Core-0 (T4LS_MC_system_test-core00.nnnn.bin files) and set NIA at entry point
# 2. Program MC-MPIC registers, such that command submission interrupt will
#    be routed to MC Core-0
# 3. Program the MC-Core-0 registers - MSR, IVPR so that core can
#    point to correct interrupt routine
# 4. The test which is runnig on the GPP core does the followings
#     - waits for MC initialization: it checks Firmware Status in MC GSR register (bit 0x01)
#     - send a command to a MC portal 0 and wait for ack
#       This triggers the execution of the external interrupt on MC core.
#       The interrupt handler updates the MC firmware status with ACK value (bit x02) after deasserting the interrupt.
#       The application running on the GPP core reads the firmware status and if ACK bit is set, the command is considered done.
#     - send a command to a MC portal 1 and wait for ack (the same flow like for portal 0)
# 5. Quits the simulation after GPP test is completed

type=1000 top.ccm.logging.level:0

################################################################################
#type=1000 top.cluster0.cpu0.logging.level:3
#type=1000 top.cluster0.cpu0.exts.setInstrTrace:0x0:true
#type=1000 top.cluster0.cpu0.exts.setInterruptTrace:0x0:true
#type=1000 top.configunit.regs.BRRL.write:0x1

###############################################################################
# Set Logging Level
###############################################################################
#set_global_log_level(log_levels.ERROR)
#top.mc.logging.level = log_levels.INFO
#top.mc.mpic.logging.level = log_levels.DEBUG
#for cpu in top.mc.cpu:
#   cpu.logging.level = log_levels.INFO
type=1000 top.mc.logging.level:2
type=1000 top.mc.mpic.logging.level:0
type=1000 top.mc.core0.logging.level:2

###############################################################################
# Enable tracing on MC cores - one core
###############################################################################
## To enable it, set it True
#for cpu in top.mc.cpu:
#   cpu.exts.setInstrTrace(0,False)
#   cpu.exts.setInterruptTrace(0,False)
#type=1000 top.mc.core0.exts.setInstrTrace:0x0:true
#type=1000 top.mc.core0.exts.setInterruptTrace:0x0:true

###############################################################################
# Load elf file to MC Core
###############################################################################
#top.mc.core0.thread0.exts._loadElf("T4LS_MC_system_test-core00.elf")
#type=1000 top.mc.core0.thread0.exts._loadElf:T4LS_MC_system_test-core00.elf
#type=2 addr=0x10000000 T4LS_MC_system_test-core00.10000000.bin
#type=2 addr=0x10002000 T4LS_MC_system_test-core00.10002000.bin
#type=2 addr=0x10006800 T4LS_MC_system_test-core00.10006800.bin
#type=2 addr=0x10007000 T4LS_MC_system_test-core00.10007000.bin
#type=1000 top.mc.core0.thread0.regs.NIA.write:0x10006888

###############################################################################
# Enable semi-hosting to enable prints
###############################################################################
type=1000 top.mc.core0.thread0.exts._enableSemiHosting
type=1000 top.aiop.cluster0.complex0.core0.thread0.exts._enableSemiHosting

###############################################################################
# Set MC Core instruction handling 
###############################################################################
## Setting MSR's EE bit to 1 and Setting IR address = 0x00000500
type=1000 top.mc.core0.thread0.regs.MSR.write:0x8000
type=1000 top.mc.core0.thread0.regs.IVPR.write:0x00000000

type=1000 top.mc.regs.MCFBALR.write:0x40000000


###############################################################################
# Set Logging Level
###############################################################################
type=1000 top.aiop.logging.level:4
#type=1000 top.aiop.core0.logging.level:2

###############################################################################
# Set PC of AIOP Cores to Start of IRAM
###############################################################################
#for cpu in top.aiop.cpu:
#     cpu.thread0.regs.NIA.write(0x30000000)
type=1000 top.aiop.cluster0.complex0.core0.thread0.regs.NIA.write:0x00800000
type=1000 top.aiop.cluster0.complex0.core0.thread0.regs.CTSCSR0.write:0x84000000

###############################################################################
# Set tracing on AIOP cores
###############################################################################
#for cpu in top.aiop.cpu:
type=1000 top.aiop.cluster0.complex0.core0.exts.setInstrTrace:0x0:false
type=1000 top.aiop.cluster0.complex0.core0.exts.setInterruptTrace:0x0:false

###############################################################################
# Program AIOP registers
###############################################################################
#top.aiop.cmgw.regs.ABRR.write(0xffff)
#top.aiop.cmgw.regs.WSCR.write(0x4)

# Each Workspace SRAM supports 16 Tasks
type=1000 top.aiop.cmgw.regs.WSCR.write:0x4

###############################################################################
# Program LUT via Registers
###############################################################################
# pc = 0x800100;
# pm = 0;
# fdpa = 0;
# fqcpa = 0x100;
# ptapa = 0x80;
# asapa = 0x40;
# asapo = 0;
# asaps = 1;
# spa = 0xc0;
# sps = 1;
# spo = 0;
# src = 0;
# sel = 0;
# osrm = 0;
# ep = 0;
#top.aiop.wrks.regs.EPAS.write(0x0) # epid = 0
#top.aiop.wrks.regs.EP_PC.write(0x800100)
#top.aiop.wrks.regs.EP_PM.write(0)
#top.aiop.wrks.regs.EP_FDPA.write(0x100)
#top.aiop.wrks.regs.EP_ASAPA.write(0x10040)
#top.aiop.wrks.regs.EP_PTAPA.write(0x80)
#top.aiop.wrks.regs.EP_SPA.write(0x000100C0)
#top.aiop.wrks.regs.EP_SPO.write(0)
#top.aiop.wrks.regs.EP_OSC.write(0)
type=1000 top.aiop.wrks.regs.EPAS.write:0x0
type=1000 top.aiop.wrks.regs.EP_PC.write:0x800100
type=1000 top.aiop.wrks.regs.EP_PM.write:0x0
type=1000 top.aiop.wrks.regs.EP_FDPA.write:0x100
type=1000 top.aiop.wrks.regs.EP_ASAPA.write:0x10040
type=1000 top.aiop.wrks.regs.EP_PTAPA.write:0x80
type=1000 top.aiop.wrks.regs.EP_SPA.write:0x000100C0
type=1000 top.aiop.wrks.regs.EP_SPO.write:0x0
type=1000 top.aiop.wrks.regs.EP_OSC.write:0x0

###############################################################################
# Initialize IRAM
###############################################################################
# Accel IDs
# FPDMA_ACCEL=0
# FODMA_ACCEL=1
# TLU_ACCEL=2
#opcode  = [0x7c,0x0,0x0,0x7c] #wait
#top.aiop.iram.mem.real.write(0x0,opcode)
type=1000 top.aiop.cluster0.iram.mem.real.write:0x0:0x7c,0x0,0x0,0x7c
type=1000 top.aiop.cluster1.iram.mem.real.write:0x0:0x7c,0x0,0x0,0x7c
type=1000 top.aiop.cluster2.iram.mem.real.write:0x0:0x7c,0x0,0x0,0x7c
type=1000 top.aiop.cluster3.iram.mem.real.write:0x0:0x7c,0x0,0x0,0x7c

#opcode  = [0x48,0x0] #se_li R0=0x0
#opcode += [0x4A,0x02] #se_li R2=0x20
#opcode += [0x44,0x20] #se_or R2,R0 (R0 = R0 | R2)
#opcode += [0x70,0x80,0x06,0x11] #e_li R4=0x00000611
#opcode += [0xd0,0x40] #se_stw R4,(R0)
#opcode += [0x4A,0x42] #se_li R2=0x24
#opcode += [0x44,0x20] #se_or R2,R0 (R0 = R0 | R2)
##opcode += [0x70,0x80,0x00,0x24] #e_li R4=0x00000024
#opcode += [0x70,0x80,0xE0,0xF0] #e_lis (R4=0xF00000)
#opcode += [0x49,0x21] #se_li (R1 = 0x17)
#opcode += [0x44,0x14] #se_or (R4 = R4 | R1)
#opcode += [0xd0,0x40] #se_stw R4,(R0)
#opcode += [0x48,0x02] #se_li R2=0x0
#opcode += [0x18,0x00,0x30,0x18] #e_hwaccel FDMA_ACCEL FDMA_ENQUEUE_CMD
#opcode += [0x7c,0x0,0x0,0x7c] #wait

###############################################################################
# Initialize FD
###############################################################################
# Address = 0x40000000 
# Length = 0x40
# Offset = 0x100
# Format = 0x0
# PTA = 0x1
# ASAL = 0x1
#fd = [0,0,0,0x40, 0,0,0,0, 0x40,0,0,0, 0xde,0xad,0,1, 0,0,0,0, 0,0,0xe1,0, 0,0,0,0, 0,0,0,0]

################################################################################
# END: demo_ls/aiop/aiop_init.py
################################################################################
#top.aiop.iram.mem.real.write(0x100,opcode)
type=1000 top.aiop.cluster0.iram.mem.real.write:0x100:0x48,0x0, 0x4A,0x02, 0x44,0x20, 0x70,0x80,0x06,0x11, 0xd0,0x40, 0x4A,0x42, 0x44,0x20, 0x70,0x80,0xE0,0xF0, 0x49,0x21, 0x44,0x14, 0xd0,0x40, 0x48,0x02, 0x18,0x00,0x30,0x18, 0x7c,0x0,0x0,0x7c
type=1000 top.aiop.cluster1.iram.mem.real.write:0x100:0x48,0x0, 0x4A,0x02, 0x44,0x20, 0x70,0x80,0x06,0x11, 0xd0,0x40, 0x4A,0x42, 0x44,0x20, 0x70,0x80,0xE0,0xF0, 0x49,0x21, 0x44,0x14, 0xd0,0x40, 0x48,0x02, 0x18,0x00,0x30,0x18, 0x7c,0x0,0x0,0x7c
type=1000 top.aiop.cluster2.iram.mem.real.write:0x100:0x48,0x0, 0x4A,0x02, 0x44,0x20, 0x70,0x80,0x06,0x11, 0xd0,0x40, 0x4A,0x42, 0x44,0x20, 0x70,0x80,0xE0,0xF0, 0x49,0x21, 0x44,0x14, 0xd0,0x40, 0x48,0x02, 0x18,0x00,0x30,0x18, 0x7c,0x0,0x0,0x7c
type=1000 top.aiop.cluster3.iram.mem.real.write:0x100:0x48,0x0, 0x4A,0x02, 0x44,0x20, 0x70,0x80,0x06,0x11, 0xd0,0x40, 0x4A,0x42, 0x44,0x20, 0x70,0x80,0xE0,0xF0, 0x49,0x21, 0x44,0x14, 0xd0,0x40, 0x48,0x02, 0x18,0x00,0x30,0x18, 0x7c,0x0,0x0,0x7c


type=1000 top.bman.logging.level:4
type=1000 top.qman.logging.level:4
